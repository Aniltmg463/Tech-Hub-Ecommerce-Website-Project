# Deployment Diagram - Infrastructure and Deployment

## Overview
This document contains Deployment Diagrams for the TechHub E-Commerce system. These diagrams show the physical deployment of software components on hardware nodes, network topology, and infrastructure configuration.

## Deployment Diagrams

### 1. Development Environment Deployment

```plantuml
@startuml Development_Deployment

title TechHub E-Commerce - Development Environment

node "Developer Workstation\n(localhost)" {
    node "Web Browser" {
        artifact "React Dev Server" <<runtime>> {
            component "React App" as reactDev
        }
        note right: Port 3000
    }

    node "Node.js Runtime" {
        artifact "Express Server" <<runtime>> {
            component "Backend API" as backendDev
        }
        note right: Port 8080
    }

    artifact "Development Tools" {
        component "Nodemon" as nodemon
        component "React Scripts" as reactScripts
    }

    nodemon -down-> backendDev : auto-restart
    reactScripts -down-> reactDev : hot reload
}

cloud "MongoDB Atlas\n(Cloud Database)" {
    database "Development DB" as devDB {
        component "users"
        component "products"
        component "categories"
        component "orders"
    }
}

cloud "Braintree Sandbox" {
    component "Test Payment API" as braintreeSandbox
}

reactDev -down-> backendDev : HTTP\nlocalhost:8080
backendDev -down-> devDB : Mongoose\nMongoDB Atlas
backendDev -right-> braintreeSandbox : Test transactions

note bottom of devDB
  **Development Database:**
  • Test data only
  • Shared across team
  • Can be reset anytime
  • IP: Whitelisted dev IPs
end note

note bottom of braintreeSandbox
  **Sandbox Environment:**
  • Test credit cards
  • No real transactions
  • Full API features
  • Separate credentials
end note

note top of "Developer Workstation\n(localhost)"
  **Running the App:**
  1. Terminal 1: npm run server (backend)
  2. Terminal 2: npm start --prefix ./client (frontend)
  OR
  3. Single command: npm run dev (both)
end note

@enduml
```

### 2. Production Environment Deployment

```plantuml
@startuml Production_Deployment

title TechHub E-Commerce - Production Environment

actor "End Users" as users

node "CDN / Static Hosting\n(e.g., Vercel, Netlify)" {
    artifact "Static Files" {
        component "HTML/CSS/JS" as staticFiles
        component "Optimized React Build" as reactBuild
    }
}

node "Application Server\n(e.g., AWS EC2, Heroku)" {
    node "Load Balancer" {
        component "Nginx / ALB" as lb
    }

    node "App Server Instance 1" {
        artifact "Node.js Process" {
            component "Express Server #1" as server1
        }
        note right: Port 8080
    }

    node "App Server Instance 2" {
        artifact "Node.js Process" {
            component "Express Server #2" as server2
        }
        note right: Port 8080
    }

    artifact "Process Manager" {
        component "PM2" as pm2
    }

    pm2 -down-> server1 : manages
    pm2 -down-> server2 : manages
}

cloud "MongoDB Atlas\n(Production Cluster)" {
    database "Production DB" {
        node "Primary" {
            component "Replica 1" as replica1
        }
        node "Secondary" {
            component "Replica 2" as replica2
        }
        node "Secondary" {
            component "Replica 3" as replica3
        }
    }
}

cloud "Braintree Production" {
    component "Live Payment API" as braintreeLive
}

cloud "Email Service\n(e.g., SendGrid)" {
    component "SMTP Server" as smtp
}

cloud "Monitoring\n(e.g., CloudWatch)" {
    component "Logs & Metrics" as monitoring
}

' User connections
users -down-> staticFiles : HTTPS\n443
users -down-> lb : HTTPS\nREST API

' Load balancer
lb -down-> server1
lb -down-> server2

' Backend connections
server1 -down-> replica1 : Mongoose
server2 -down-> replica1 : Mongoose

replica1 -right-> replica2 : replication
replica1 -right-> replica3 : replication

server1 -right-> braintreeLive : Payment processing
server2 -right-> braintreeLive : Payment processing

server1 -down-> smtp : Email sending
server2 -down-> smtp : Email sending

server1 -right-> monitoring : Logs
server2 -right-> monitoring : Logs
lb -up-> monitoring : Metrics

note top of staticFiles
  **Static Hosting:**
  • npm run build
  • Optimized production build
  • Minified JS/CSS
  • CDN distribution
  • HTTPS only
end note

note right of lb
  **Load Balancing:**
  • Distributes traffic
  • Health checks
  • SSL/TLS termination
  • Horizontal scaling
end note

note bottom of "Production DB"
  **High Availability:**
  • 3-node replica set
  • Automatic failover
  • Read scaling
  • Point-in-time backup
  • 99.995% uptime SLA
end note

note bottom of pm2
  **Process Management:**
  • Auto-restart on crash
  • Zero-downtime reload
  • Cluster mode
  • Log management
  • Memory monitoring
end note

@enduml
```

### 3. Network Topology Diagram

```plantuml
@startuml Network_Topology

title TechHub E-Commerce - Network Topology

cloud "Internet" {
    [Users Worldwide] as users
}

rectangle "DMZ (Demilitarized Zone)" {
    node "Firewall / WAF" {
        component "DDoS Protection" as ddos
        component "SSL/TLS Termination" as ssl
    }

    node "Load Balancer" {
        component "Traffic Distribution" as lb
        component "Health Checks" as health
    }
}

rectangle "Application Tier\n(Private Subnet)" {
    node "App Server 1\n10.0.1.10" {
        component "Express" as app1
    }

    node "App Server 2\n10.0.1.11" {
        component "Express" as app2
    }

    node "App Server 3\n10.0.1.12" {
        component "Express" as app3
    }
}

rectangle "External Services\n(Public Internet)" {
    cloud "MongoDB Atlas" {
        database "Database Cluster" as dbCluster
    }

    cloud "Braintree" {
        component "Payment Gateway" as payment
    }

    cloud "Email Service" {
        component "SMTP" as email
    }
}

' Network connections
users -down-> ddos : HTTPS (443)
ddos -down-> ssl
ssl -down-> lb
lb -down-> app1 : HTTP (8080)
lb -down-> app2 : HTTP (8080)
lb -down-> app3 : HTTP (8080)

app1 -right-> dbCluster : MongoDB\nProtocol (27017)
app2 -right-> dbCluster
app3 -right-> dbCluster

app1 -down-> payment : HTTPS (443)
app2 -down-> payment
app3 -down-> payment

app1 -down-> email : SMTP (587)
app2 -down-> email
app3 -down-> email

note right of "DMZ (Demilitarized Zone)"
  **Security Layer:**
  • Public-facing
  • DDoS mitigation
  • SSL/TLS encryption
  • Rate limiting
  • IP filtering
end note

note right of "Application Tier\n(Private Subnet)"
  **Private Network:**
  • No direct internet access
  • Outbound only via NAT
  • Security groups
  • Internal load balancing
  • Auto-scaling group
end note

note bottom of dbCluster
  **Database Security:**
  • IP whitelist (app servers)
  • TLS encryption
  • VPC peering (optional)
  • Authentication required
  • Private endpoints
end note

@enduml
```

### 4. Container Deployment (Docker - Optional)

```plantuml
@startuml Docker_Deployment

title TechHub E-Commerce - Docker Container Deployment

node "Docker Host" {
    node "Docker Container: Frontend" {
        artifact "nginx:alpine" {
            component "React Build\nStatic Files" as frontend
        }
        note right: Port 80 → 3000
    }

    node "Docker Container: Backend" {
        artifact "node:18-alpine" {
            component "Express Server" as backend
        }
        note right: Port 8080
    }

    artifact "Docker Compose" {
        component "Service Orchestration" as compose
    }

    artifact "Volumes" {
        component "App Logs" as logs
        component "Uploads" as uploads
    }
}

cloud "External Services" {
    database "MongoDB Atlas" as db
    component "Braintree" as braintree
}

compose -down-> frontend : manages
compose -down-> backend : manages

frontend -down-> backend : API calls\nhttp://backend:8080

backend -down-> db : Mongoose
backend --> logs : write logs
backend --> uploads : store files
backend -right-> braintree : payments

note right of compose
  **docker-compose.yml:**
  ```yaml
  services:
    frontend:
      build: ./client
      ports: ["3000:80"]
      depends_on: [backend]

    backend:
      build: .
      ports: ["8080:8080"]
      environment:
        - MONGO_URL
        - JWT_SECRET
      volumes:
        - ./logs:/app/logs
  ```
end note

note right of frontend
  **Frontend Dockerfile:**
  ```dockerfile
  FROM node:18-alpine AS build
  WORKDIR /app
  COPY package*.json ./
  RUN npm install
  COPY . .
  RUN npm run build

  FROM nginx:alpine
  COPY --from=build /app/build /usr/share/nginx/html
  ```
end note

note right of backend
  **Backend Dockerfile:**
  ```dockerfile
  FROM node:18-alpine
  WORKDIR /app
  COPY package*.json ./
  RUN npm install
  COPY . .
  EXPOSE 8080
  CMD ["node", "index.js"]
  ```
end note

@enduml
```

### 5. Cloud Infrastructure Deployment (AWS Example)

```plantuml
@startuml AWS_Deployment

title TechHub E-Commerce - AWS Cloud Deployment

!define AWSPuml https://raw.githubusercontent.com/awslabs/aws-icons-for-plantuml/v14.0/dist

rectangle "AWS Cloud" {
    rectangle "VPC (10.0.0.0/16)" {
        rectangle "Public Subnet (10.0.1.0/24)" {
            node "Application Load Balancer" as alb
            node "NAT Gateway" as nat
        }

        rectangle "Private Subnet 1 (10.0.2.0/24)\nAZ: us-east-1a" {
            node "EC2 Instance 1" {
                component "Express Server" as ec2_1
            }
        }

        rectangle "Private Subnet 2 (10.0.3.0/24)\nAZ: us-east-1b" {
            node "EC2 Instance 2" {
                component "Express Server" as ec2_2
            }
        }
    }

    node "CloudFront CDN" as cf
    node "S3 Bucket" as s3
    node "Route 53 DNS" as dns
    node "CloudWatch" as cw
    node "Systems Manager\n(Parameter Store)" as ssm
}

cloud "External" {
    database "MongoDB Atlas" as mongo
    component "Braintree" as bt
    [Users] as users
}

' User flow
users --> dns : DNS query
dns --> cf : route to CDN
cf --> s3 : serve static files
cf --> alb : API requests

' Load balancing
alb --> ec2_1
alb --> ec2_2

' Private subnet
ec2_1 --> nat : outbound traffic
ec2_2 --> nat : outbound traffic

' External services
ec2_1 --> mongo : via NAT
ec2_2 --> mongo : via NAT
ec2_1 --> bt : via NAT
ec2_2 --> bt : via NAT

' Monitoring & config
ec2_1 --> cw : logs & metrics
ec2_2 --> cw : logs & metrics
ec2_1 --> ssm : get secrets
ec2_2 --> ssm : get secrets

note top of cf
  **CloudFront:**
  • Global CDN
  • HTTPS only
  • Cache static assets
  • Origin: S3 (frontend)
  • Custom domain
end note

note right of s3
  **S3 Static Hosting:**
  • React build artifacts
  • Versioning enabled
  • Public read access
  • Lifecycle policies
end note

note bottom of alb
  **Application Load Balancer:**
  • Target: EC2 instances
  • Health checks
  • SSL/TLS termination
  • Path-based routing
  • Sticky sessions
end note

note bottom of ec2_1
  **EC2 Configuration:**
  • Instance type: t3.medium
  • AMI: Amazon Linux 2
  • Auto Scaling Group
  • User data: Install Node.js
  • Security group: Port 8080
end note

note bottom of ssm
  **Parameter Store:**
  • MONGO_URL (SecureString)
  • JWT_SECRET (SecureString)
  • BRAINTREE_* (SecureString)
  • Encrypted at rest
  • IAM access control
end note

@enduml
```

## How to View These Diagrams

### In VS Code
1. Install "PlantUML" extension by jebbs
2. Copy each PlantUML code block
3. Create separate `.puml` files
4. Press `Alt+D` to preview

### Online
1. Go to: http://www.plantuml.com/plantuml/uml/
2. Copy code between \`\`\`plantuml tags
3. Paste and view

## Deployment Explanations

### 1. Development Environment

**Purpose:** Local development setup for developers.

**Components:**
- **React Dev Server** (Port 3000)
  - Hot module replacement
  - Source maps for debugging
  - Development mode warnings
  - Fast refresh

- **Express Server** (Port 8080)
  - Nodemon auto-restart
  - Detailed error messages
  - Console logging (Morgan)
  - Development mode

- **MongoDB Atlas** (Cloud)
  - Shared development database
  - Test data
  - Can be reset
  - IP whitelist for developers

- **Braintree Sandbox**
  - Test payment environment
  - Fake credit card numbers
  - No real transactions
  - Full API simulation

**Running Development:**
```bash
# Option 1: Run separately
Terminal 1: npm run server
Terminal 2: npm run client

# Option 2: Run concurrently
npm run dev
```

### 2. Production Environment

**Purpose:** Live production deployment for end users.

**Architecture:**
- **CDN / Static Hosting** (Frontend)
  - Serves optimized React build
  - Global CDN distribution
  - HTTPS enforced
  - Minified assets
  - Examples: Vercel, Netlify, S3 + CloudFront

- **Application Servers** (Backend)
  - Multiple instances (horizontal scaling)
  - Load balancer (Nginx / AWS ALB)
  - Process manager (PM2)
  - Auto-restart on failure
  - Zero-downtime deployment
  - Examples: AWS EC2, Heroku, DigitalOcean

- **MongoDB Atlas** (Database)
  - Production cluster
  - 3-node replica set
  - Automatic failover
  - Point-in-time backups
  - 99.995% uptime SLA

- **External Services**
  - Braintree Production API
  - Email service (SendGrid, AWS SES)
  - Monitoring (CloudWatch, DataDog)

**Deployment Process:**
```bash
# Frontend
cd client
npm run build
# Deploy build/ folder to static hosting

# Backend
git push heroku main
# OR
pm2 start index.js --name "techhub-api"
```

### 3. Network Topology

**Purpose:** Shows network layers and security zones.

**Network Layers:**

1. **DMZ (Demilitarized Zone)**
   - Public-facing layer
   - Firewall / WAF (Web Application Firewall)
   - DDoS protection
   - SSL/TLS termination
   - Load balancer

2. **Application Tier (Private Subnet)**
   - No direct internet access
   - Outbound via NAT gateway
   - Multiple app server instances
   - Private IP addresses (10.0.1.x)
   - Security groups restrict traffic

3. **External Services**
   - MongoDB Atlas (cloud database)
   - Braintree (payment gateway)
   - Email service (SMTP)
   - Accessed via HTTPS

**Security Measures:**
- ✅ Firewall rules
- ✅ SSL/TLS encryption
- ✅ Private subnets
- ✅ IP whitelisting
- ✅ DDoS protection
- ✅ Rate limiting
- ✅ Security groups

### 4. Container Deployment (Docker)

**Purpose:** Containerized deployment for consistency.

**Containers:**

1. **Frontend Container**
   - Base: nginx:alpine
   - Contains: React production build
   - Serves static files
   - Lightweight (~50MB)

2. **Backend Container**
   - Base: node:18-alpine
   - Contains: Express server
   - Node.js runtime
   - Dependencies included

**Benefits of Docker:**
- ✅ Consistent environments (dev = prod)
- ✅ Easy deployment
- ✅ Isolation
- ✅ Portability
- ✅ Orchestration with Docker Compose / Kubernetes

**Docker Compose Example:**
```yaml
version: '3.8'
services:
  frontend:
    build: ./client
    ports:
      - "3000:80"
    depends_on:
      - backend

  backend:
    build: .
    ports:
      - "8080:8080"
    environment:
      - MONGO_URL=${MONGO_URL}
      - JWT_SECRET=${JWT_SECRET}
    volumes:
      - ./logs:/app/logs
```

### 5. AWS Cloud Deployment

**Purpose:** Enterprise-grade cloud deployment on AWS.

**AWS Services Used:**

| Service | Purpose |
|---------|---------|
| **Route 53** | DNS management, domain routing |
| **CloudFront** | Global CDN for frontend |
| **S3** | Static file hosting (React build) |
| **ALB** | Application Load Balancer |
| **EC2** | Application servers (Express) |
| **VPC** | Virtual Private Cloud (networking) |
| **NAT Gateway** | Outbound internet for private subnets |
| **CloudWatch** | Logging and monitoring |
| **Systems Manager** | Secure parameter storage |
| **Auto Scaling** | Automatic scaling based on load |

**VPC Configuration:**
- **VPC CIDR**: 10.0.0.0/16
- **Public Subnet**: 10.0.1.0/24 (ALB, NAT)
- **Private Subnet 1**: 10.0.2.0/24 (AZ: us-east-1a)
- **Private Subnet 2**: 10.0.3.0/24 (AZ: us-east-1b)

**High Availability:**
- Multi-AZ deployment
- Auto Scaling Group
- Health checks
- Automatic failover
- Load balancing

**Security:**
- Private subnets for app servers
- NAT Gateway for outbound traffic
- Security groups restrict inbound
- Secrets in Parameter Store (encrypted)
- TLS in transit

## Deployment Checklist

### Pre-Deployment

- [ ] Environment variables configured
- [ ] Database connection tested
- [ ] SSL certificates obtained
- [ ] Domain DNS configured
- [ ] Payment gateway credentials (production)
- [ ] Email service configured
- [ ] Monitoring and logging setup
- [ ] Backup strategy defined

### Frontend Deployment

- [ ] Run `npm run build`
- [ ] Test production build locally
- [ ] Upload to static hosting / CDN
- [ ] Configure custom domain
- [ ] Enable HTTPS
- [ ] Test all routes work
- [ ] Verify API calls work

### Backend Deployment

- [ ] Install Node.js on server
- [ ] Clone repository
- [ ] Run `npm install`
- [ ] Set environment variables
- [ ] Test database connection
- [ ] Start with process manager (PM2)
- [ ] Configure reverse proxy (Nginx)
- [ ] Enable SSL/TLS
- [ ] Test all API endpoints
- [ ] Monitor logs

### Post-Deployment

- [ ] Smoke tests on production
- [ ] Performance testing
- [ ] Security scan
- [ ] Monitoring alerts configured
- [ ] Backup verification
- [ ] Documentation updated
- [ ] Team notified

## Deployment Environments

| Environment | Purpose | Database | Payments | URL |
|-------------|---------|----------|----------|-----|
| **Development** | Local coding | Dev DB (Atlas) | Sandbox | localhost:3000 |
| **Staging** | Pre-production testing | Staging DB | Sandbox | staging.techhub.com |
| **Production** | Live system | Production DB | Live | www.techhub.com |

## Scaling Strategy

### Vertical Scaling
- Upgrade EC2 instance types
- Increase MongoDB cluster tier
- Add more RAM/CPU

### Horizontal Scaling
- Add more EC2 instances
- Auto Scaling Group
- Load balancer distributes traffic
- MongoDB read replicas

### Caching Strategy
- CloudFront caching (frontend)
- Redis for session/cart data
- API response caching
- Database query caching

## Disaster Recovery

### Backup Strategy
- **Database**: Automatic daily backups (MongoDB Atlas)
- **Code**: Git version control
- **Configuration**: Infrastructure as Code (Terraform, CloudFormation)
- **Media**: Product images in database

### Recovery Procedures
1. **Database Restore**: Restore from MongoDB Atlas backup
2. **Application**: Deploy from Git repository
3. **Configuration**: Apply infrastructure code
4. **Verification**: Run smoke tests

### RTO (Recovery Time Objective): < 2 hours
### RPO (Recovery Point Objective): < 24 hours

## Related Diagrams

- [COMPONENT_DIAGRAM.md](COMPONENT_DIAGRAM.md) - Shows software components deployed
- [SYSTEM_DESIGN.md](SYSTEM_DESIGN.md) - Shows system architecture
- [ARCHITECTURE_DIAGRAM.puml](ARCHITECTURE_DIAGRAM.puml) - High-level architecture

---

**Last Updated:** 2025-11-23
**Diagram Type:** UML Deployment Diagram
**Purpose:** Infrastructure, Deployment, and Network Architecture
